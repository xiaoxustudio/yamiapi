<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: printer.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: printer.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict'

// ******************************** 文字打印机类 ********************************

// UI文本组件中的文字打印模块
class Printer {
  /** 打印机纹理
   *  @type {Texture}
   */ texture

  /** 用来绘制文字的2D画布
   *  @type {HTMLCanvasElement}
   */ canvas

  /** 用来绘制文字的2D图形上下文
   *  @type {CanvasRenderingContext2D}
   */ context

  /** 打印的全部文本内容
   *  @type {string}
   */ content

  /** 打印的文本缓冲
   *  @type {string}
   */ buffer

  /** 当前打印位置X
   *  @type {number}
   */ x

  /** 当前打印位置Y
   *  @type {number}
   */ y

  /** 当前打印区域宽度
   *  @type {number}
   */ width

  /** 当前打印区域高度
   *  @type {number}
   */ height

  /** 当前打印的字符索引
   *  @type {number}
   */ index

  /** 换行包装的结束位置
   *  @type {number}
   */ wrapEnd

  /** 打印指令列表
   *  @type {Array&lt;Object>}
   */ commands

  /** 纹理边距(左)
   *  @type {number}
   */ paddingLeft

  /** 纹理边距(上)
   *  @type {number}
   */ paddingTop

  /** 纹理边距(右)
   *  @type {number}
   */ paddingRight

  /** 纹理边距(下)
   *  @type {number}
   */ paddingBottom

  /** 当前打印文本行的行高
   *  @type {number}
   */ lineHeight

  /** 当前打印文本行的行间距
   *  @type {number}
   */ lineSpacing

  /** 字间距
   *  @type {number}
   */ letterSpacing

  /** 是否可以换行
   *  @type {boolean}
   */ breakable

  /** 是否水平方向打印
   *  @type {boolean}
   */ horizontal

  /** 水平对齐系数
   *  @type {number}
   */ alignmentFactorX

  /** 垂直对齐系数
   *  @type {number}
   */ alignmentFactorY

  /** 是否自动换行
   *  @type {boolean}
   */ wordWrap

  /** 是否对溢出的文字进行截断
   *  @type {boolean}
   */ truncate

  /** 打印区域宽度
   *  @type {number}
   */ printWidth

  /** 打印区域高度
   *  @type {number}
   */ printHeight

  /** 打印字体列表
   *  @type {Array&lt;string>}
   */ fonts

  /** 打印样式列表
   *  @type {Array&lt;string>}
   */ styles

  /** 打印粗细列表
   *  @type {Array&lt;string>}
   */ weights

  /** 打印字体大小列表
   *  @type {Array&lt;number>}
   */ sizes

  /** 打印文字颜色列表
   *  @type {Array&lt;number>}
   */ colors

  /** 打印文字效果列表
   *  @type {Array&lt;Object>}
   */ effects

  // 私有属性
  _direction        //:string
  _horizontalAlign  //:string
  _verticalAlign    //:string

  /**
   * 文字打印机对象
   * @param {Texture} texture 打印机纹理
   */
  constructor(texture) {
    texture.base.printer = this
    texture.base.onRestore = Printer.restoreTexture
    this.texture = texture
    this.canvas = document.createElement('canvas')
    this.canvas.width = 0
    this.canvas.height = 0
    this.context = this.canvas.getContext('2d')
    this.content = ''
    this.buffer = ''
    this.x = 0
    this.y = 0
    this.width = 0
    this.height = 0
    this.index = 0
    this.wrapEnd = 0
    this.commands = null
    this.paddingLeft = 0
    this.paddingTop = 0
    this.paddingRight = 0
    this.paddingBottom = 0
    this.lineHeight = 0
    this.lineSpacing = 0
    this.letterSpacing = 0
    this.breakable = false
    this.direction = 'horizontal-tb'
    this.horizontalAlign = 'left'
    this.verticalAlign = 'top'
    this.wordWrap = false
    this.truncate = false
    this.printWidth = null
    this.printHeight = null
    this.fonts = [Printer.font]
    this.styles = ['normal']
    this.weights = ['normal']
    this.sizes = [Printer.size]
    this.colors = [Printer.color]
    this.effects = [Printer.effect]
  }

  /**
   * 文字打印方向
   * @type {string}
   */
  get direction() {
    return this._direction
  }

  set direction(value) {
    this._direction = value
    switch (value) {
      case 'horizontal-tb':
        this.horizontal = true
        break
      case 'vertical-lr':
      case 'vertical-rl':
        this.horizontal = false
        break
    }
  }

  /**
   * 水平对齐模式
   * @type {string}
   */
  get horizontalAlign() {
    return this._horizontalAlign
  }

  set horizontalAlign(value) {
    this._horizontalAlign = value
    // 更新水平对齐系数
    switch (value) {
      case 'left':
        this.alignmentFactorX = 0
        break
      case 'center':
        this.alignmentFactorX = 0.5
        break
      case 'right':
        this.alignmentFactorX = 1
        break
    }
  }

  /**
   * 垂直对齐模式
   * @type {string}
   */
  get verticalAlign() {
    return this._verticalAlign
  }

  set verticalAlign(value) {
    this._verticalAlign = value
    // 更新垂直对齐系数
    switch (value) {
      case 'top':
        this.alignmentFactorY = 0
        break
      case 'middle':
        this.alignmentFactorY = 0.5
        break
      case 'bottom':
        this.alignmentFactorY = 1
        break
    }
  }

  /**
   * 重置打印机上下文
   * @returns {Printer}
   */
  reset() {
    this.content = ''
    this.x = 0
    this.y = 0
    this.width = 0
    this.height = 0
    this.index = 0
    this.wrapEnd = 0
    this.lineHeight = 0
    this.breakable = false
    const {fonts, styles, weights, sizes, colors, effects} = this
    if (fonts.length !== 1) this.fonts = [fonts[fonts.length - 1]]
    if (styles.length !== 1) this.styles = [styles[styles.length - 1]]
    if (weights.length !== 1) this.weights = [weights[weights.length - 1]]
    if (sizes.length !== 1) this.sizes = [sizes[sizes.length - 1]]
    if (colors.length !== 1) this.colors = [colors[colors.length - 1]]
    if (effects.length !== 1) this.effects = [effects[effects.length - 1]]
    return this
  }

  /** 更新打印机字体 */
  updateFont() {
    const style = this.styles[0]
    const weight = this.weights[0]
    const size = this.sizes[0]
    const family = this.fonts.join(', ')
    const context = this.context
    // 设置canvas2d上下文的字体，斜体字内边距，垂直内边距(一些字体可能垂直溢出)
    context.font = `${style} normal ${weight} ${size}px ${family}`
    context.paddingItalic = style === 'italic' ? Math.ceil(size / 4) : 0
    context.paddingVertical = Math.ceil(size / 10)
    context.size = size
  }

  /** 计算纹理内边距 */
  calculatePadding() {
    const context = this.context
    const effect = this.effects[0]
    const {paddingItalic} = context
    const {paddingVertical} = context
    switch (effect.type) {
      case 'none':
        // 文字效果：无，负数x/y将会增加左/上的内边距
        this.paddingLeft = Math.max(-this.x, this.paddingLeft)
        this.paddingTop = Math.max(paddingVertical - this.y, this.paddingTop)
        this.paddingRight = Math.max(paddingItalic, this.paddingRight)
        this.paddingBottom = Math.max(paddingVertical, this.paddingBottom)
        break
      case 'shadow': {
        // 文字效果：阴影，根据阴影偏移方向来增加内边距
        const {shadowOffsetX, shadowOffsetY} = effect
        const shadowOffsetLeft = Math.max(-shadowOffsetX, 0)
        const shadowOffsetTop = Math.max(-shadowOffsetY, 0)
        const shadowOffsetRight = Math.max(shadowOffsetX, 0)
        const shadowOffsetBottom = Math.max(shadowOffsetY, 0)
        this.paddingLeft = Math.max(shadowOffsetLeft - this.x, this.paddingLeft)
        this.paddingTop = Math.max(shadowOffsetTop + paddingVertical - this.y, this.paddingTop)
        this.paddingRight = Math.max(shadowOffsetRight + paddingItalic, this.paddingRight)
        this.paddingBottom = Math.max(shadowOffsetBottom + paddingVertical, this.paddingBottom)
        break
      }
      case 'stroke': {
        // 文字效果：描边，上下左右增加描边宽度一半的内边距
        const halfWidth = Math.ceil(effect.strokeWidth / 2)
        this.paddingLeft = Math.max(halfWidth - this.x, this.paddingLeft)
        this.paddingTop = Math.max(halfWidth + paddingVertical - this.y, this.paddingTop)
        this.paddingRight = Math.max(halfWidth + paddingItalic, this.paddingRight)
        this.paddingBottom = Math.max(halfWidth + paddingVertical, this.paddingBottom)
        break
      }
      case 'outline':
        // 文字效果：轮廓，上下左右增加1px的内边距
        this.paddingLeft = Math.max(1 - this.x, this.paddingLeft)
        this.paddingTop = Math.max(1 + paddingVertical - this.y, this.paddingTop)
        this.paddingRight = Math.max(1 + paddingItalic, this.paddingRight)
        this.paddingBottom = Math.max(1 + paddingVertical, this.paddingBottom)
        break
    }
  }

  /**
   * 测量字符串像素宽度
   * @param {string} string 目标字符串
   * @returns {number}
   */
  measureWidth(string) {
    if (this.horizontal) {
      // 水平方向的文本返回字符串宽度
      return this.context.measureText(string).width
    } else {
      // 垂直方向的文本返回字符串长度 * 字体大小
      return this.sizes[0] * string.length
    }
  }

  /**
   * 测量字符串像素高度
   * @param {string} string 目标字符串
   * @returns {number}
   */
  measureHeight(string) {
    if (this.horizontal) {
      // 水平方向返回字体大小
      return this.sizes[0]
    } else {
      // 垂直方向返回最大的字符宽度
      let height = 0
      const context = this.context
      const length = string.length
      for (let i = 0; i &lt; length; i++) {
        height = Math.max(height,
          context.measureText(string[i]).width,
        )
      }
      return height
    }
  }

  /** 绘制缓冲字符串 */
  drawBuffer() {
    const string = this.buffer

    // 如果缓冲字符串为空，返回
    if (string === '') return

    // 计算内边距
    this.calculatePadding()

    // 设置绘制指令
    const context = this.context
    const color = this.colors[0]
    const effect = this.effects[0]
    const horizontal = this.horizontal
    let measureWidth = Printer.lineWidth
    if (measureWidth === 0) {
      // 如果不存在字间距和强制换行
      // 则不会提前测量出字符串宽度
      measureWidth = this.measureWidth(string)
    }
    const measureHeight = this.measureHeight(string)
    const commands = this.commands
    const command = Printer.fetchCommand()
    // 设置打印机指令
    commands.push(command)
    command.string = string
    command.x = this.x
    command.y = this.y
    command.font = context.font
    command.size = context.size
    command.color = color
    command.effect = effect
    command.horizontalWidth = horizontal ? measureWidth : measureHeight
    command.drawingMethod = Printer[Printer.drawingMethods[effect.type]]

    // 重置行宽
    Printer.lineWidth = 0

    // 重置属性(通用)
    this.buffer = ''
    this.breakable = true
    // 根据不同的文本方向，计算下一个位置、行高、文本区域宽度、文本区域高度
    if (horizontal) {
      this.x += measureWidth
      this.lineHeight = Math.max(this.lineHeight, measureHeight)
      this.width = Math.max(this.width, this.x)
      this.height = Math.max(this.height, this.y + this.lineHeight)
    } else {
      this.y += measureWidth
      this.lineHeight = Math.max(this.lineHeight, measureHeight)
      this.width = Math.max(this.width, this.x + this.lineHeight)
      this.height = Math.max(this.height, this.y)
    }
  }

  /** 计算文本位置 */
  calculateTextPosition() {
    switch (this.direction) {
      case 'horizontal-tb':
      case 'vertical-lr':
        break
      case 'vertical-rl': {
        // 文本方向：垂直(从右到左)
        // 以下算法将文本排版(左右)翻转成(右左)
        const commands = this.commands
        const length = commands.length
        // 设置初始x为最右端位置
        let x = this.width
        let index = 0
        let lineX
        let lineHeight
        // 遍历所有打印机指令
        for (let i = 0; i &lt; length; i++) {
          const command = commands[i]
          // 当文本的水平位置发生变化(换行)
          if (lineX !== command.x) {
            while (index &lt; i) {
              // 上一行文本的位置 = 右侧位置 - 行高
              commands[index++].x = x - lineHeight
            }
            if (lineX !== undefined) {
              // 右侧位置减去行高和行间距
              x -= command.x - lineX
            }
            // 设置上一次文本行X
            lineX = command.x
            lineHeight = 0
          }
          // 获取最大的水平宽度作为行高
          lineHeight = Math.max(lineHeight, command.horizontalWidth)
        }
        while (index &lt; length) {
          // 最后一行文本的位置 = 右侧位置 - 行高
          commands[index++].x = x - lineHeight
        }
        break
      }
    }
    if (this.horizontal) {
      // 对水平方向的文本进行水平对齐(不考虑垂直对齐)
      const factor = this.alignmentFactorX
      if (factor !== 0) {
        const {commands, letterSpacing} = this
        // 打印机文本区域宽度已经减去字间距调整过，加回去
        const lineWidth = this.width + letterSpacing
        let lineX
        let lineY
        // 逆序遍历打印机指令
        for (let i = commands.length - 1; i >= 0; i--) {
          const command = commands[i]
          // 当文本的垂直位置发生变化时(换行)
          // 计算当前行的水平偏移距离
          if (lineY !== command.y) {
            lineY = command.y
            lineX = factor * (
              lineWidth
            - command.x
            - command.horizontalWidth
            )
          }
          command.x += lineX
        }
      }
    } else {
      // 对垂直方向的文本进行垂直对齐(不考虑水平对齐)
      const factor = this.alignmentFactorY
      if (factor !== 0) {
        const {commands, letterSpacing} = this
        // 打印机文本区域高度已经减去字间距调整过，加回去
        const lineWidth = this.height + letterSpacing
        let lineX
        let lineY
        // 逆序遍历打印机指令
        for (let i = commands.length - 1; i >= 0; i--) {
          const command = commands[i]
          // 当文本的水平位置发生变化时(换行)
          // 计算当前行的垂直偏移距离
          if (lineX !== command.x) {
            lineX = command.x
            lineY = factor * (
              lineWidth
            - command.y
            - command.string.length
            * (command.size + letterSpacing)
            )
          }
          command.y += lineY
        }
      }
    }
  }

  /** 执行绘制指令 */
  executeCommands() {
    const context = this.context
    const commands = this.commands
    const length = commands.length
    const horizontal = this.horizontal
    const paddingLeft = this.paddingLeft
    const paddingTop = this.paddingTop
    const letterSpacing = this.letterSpacing
    const charWidths = Printer.charWidths
    let charIndex = 0
    for (let i = 0; i &lt; length; i++) {
      const command = commands[i]
      const string = command.string
      const drawingMethod = command.drawingMethod
      // 调整打印机指令的打印位置
      command.x += paddingLeft
      command.y += paddingTop
      if (horizontal) {
        // 打印水平方向的文字
        if (letterSpacing !== 0) {
          // 如果设置了字间距，逐个打印字符
          const length = string.length
          for (let i = 0; i &lt; length; i++) {
            const charWidth = charWidths[charIndex++]
            drawingMethod(context, command, string[i])
            command.x += charWidth + letterSpacing
          }
        } else {
          // 如果没有设置字间距，一次性打印字符串
          drawingMethod(context, command, string)
        }
      } else {
        // 打印垂直方向的文字，逐个打印字符
        const size = command.size
        const length = string.length
        for (let i = 0; i &lt; length; i++) {
          drawingMethod(context, command, string[i])
          command.y += size + letterSpacing
        }
      }
    }
    this.commands = null
    this.texture.fromImage(this.canvas)

    // 重置指令池
    Printer.resetCommands()
  }

  // 检查包裹文本是否溢出
  isWrapOverflowing() {
    const {content} = this
    const {length} = content
    let string = ''
    let wrapEnd = length
    outer: for (let i = this.index; i &lt; length; i++) {
      const char = content[i]
      switch (char) {
        case ' ': case '-': case '\n': case '&lt;':
          // 跳过重复的字符
          while (++i &lt; length &amp;&amp; content[i] === char) {}
          wrapEnd = i
          break outer
      }
      string += char
    }
    this.wrapEnd = wrapEnd
    return string === ''
    ? false
    : this.horizontal
    ? this.x + Printer.lineWidth + this.measureWidth(string) > this.printWidth
    : this.y + Printer.lineWidth + this.measureWidth(string) > this.printHeight
  }

  /** 换行 */
  newLine() {
    // 禁止头部换行和连续换行
    if (this.breakable) {
      this.breakable = false
      if (this.horizontal) {
        // 水平方向换行，垂直位置加上行高和行间距，重置水平位置、行高
        this.x = 0
        this.y += (this.lineHeight || this.sizes[0]) + this.lineSpacing
        this.lineHeight = 0
      } else {
        // 垂直方向换行，水平位置加上行高和行间距，重置垂直位置、行高
        this.x += (this.lineHeight || this.sizes[0]) + this.lineSpacing
        this.y = 0
        this.lineHeight = 0
      }
    }
  }

  /**
   * 绘制文本
   * @param {string} content 文本内容
   */
  draw(content) {
    // 设置内容和重置索引
    this.content = content
    this.index = 0
    this.wrapEnd = 0

    // 创建指令列表
    this.commands = []

    // 重置内边距
    this.paddingLeft = 0
    this.paddingTop = 0
    this.paddingRight = 0
    this.paddingBottom = 0

    // 更新字体
    this.updateFont()

    const wordWrap = this.wordWrap
    const truncate = this.truncate
    const horizontal = this.horizontal
    const printWidth = this.printWidth
    const printHeight = this.printHeight
    const letterSpacing = this.letterSpacing
    const charWidths = Printer.charWidths
    const length = content.length
    let charIndex = 0
    let charWidth = 0

    // 按顺序检查字符
    while (this.index &lt; length) {
      // 匹配标签
      const char = content[this.index]
      if (char === '&lt;' &amp;&amp; this.matchTag()) {
        continue
      }

      // 换行符
      if (char === '\n') {
        this.drawBuffer()
        this.newLine()
        this.index += 1
        continue
      }

      // 包裹文本溢出
      if (wordWrap &amp;&amp; Printer.wordWrap === 'keep' &amp;&amp; this.index >= this.wrapEnd &amp;&amp; this.isWrapOverflowing()) {
        this.drawBuffer()
        this.newLine()
        continue
      }

      // 截断模式：高度溢出时跳出循环
      if (truncate &amp;&amp; (horizontal
      ? this.y + Math.max(this.lineHeight, this.measureHeight(char)) > printHeight
      : this.x + Math.max(this.lineHeight, this.measureHeight(char)) > printWidth)) {
        this.drawBuffer()
        break
      }

      // 换行模式：宽度溢出时强制换行(但至少绘制一个字符)
      if (wordWrap &amp;&amp; (horizontal
      ? this.x + Printer.lineWidth + (charWidth = this.measureWidth(char)) > printWidth
      : this.y + Printer.lineWidth + (charWidth = this.measureWidth(char)) > printHeight) &amp;&amp; (
        this.breakable || this.buffer.length !== 0)) {
        this.drawBuffer()
        this.newLine()
        continue
      }

      // 如果设置了字间距
      if (letterSpacing !== 0) {
        if (wordWrap === false) {
          charWidth = this.measureWidth(char)
        }
        // 记录字符宽度
        charWidths[charIndex++] = charWidth
        // 加上字间距
        Printer.lineWidth += letterSpacing
      }
      // 加上字符宽度(存在字间距或换行模式才会计算字符宽度)
      Printer.lineWidth += charWidth

      // 放入缓冲字符串
      this.buffer += char
      this.index += 1
    }

    // 绘制缓冲字符串
    this.drawBuffer()

    // 调整文本区域大小(减去字间距)
    if (horizontal) {
      this.width = Math.max(this.width - letterSpacing, 0)
    } else {
      this.height = Math.max(this.height - letterSpacing, 0)
    }
    // 调整打印机纹理大小，限制最大宽高为16384(超过会报错)
    const width = Math.min(Math.ceil(this.width + this.paddingLeft + this.paddingRight), 16384)
    const height = Math.min(Math.ceil(this.height + this.paddingTop + this.paddingBottom), 16384)
    this.context.resize(width, height)

    // 计算文本位置
    this.calculateTextPosition()

    // 执行打印机指令进行绘制
    this.executeCommands()
  }

  /**
   * 匹配富文本标签
   * @returns {boolean} 是否成功匹配标签
   */
  matchTag() {
    const regexps = Printer.regexps
    const startIndex = this.index
    const endIndex = this.content.indexOf('>', startIndex + 1) + 1
    const string = this.content.slice(startIndex, endIndex)
    let match
    // 使用索引颜色
    if (match = string.match(regexps.colorIndex)) {
      const index = parseInt(match[1])
      const hex = Data.config.indexedColors[index].code
      const color = Color.parseCSSColor(hex)
      this.drawBuffer()
      this.colors.unshift(color)
      this.index += match[0].length
      return true
    }
    // 使用指定颜色
    if (match = string.match(regexps.color)) {
      const hex = match[1] + match[2] + match[3] + (match[4] ?? 'ff')
      const color = Color.parseCSSColor(hex)
      this.drawBuffer()
      this.colors.unshift(color)
      this.index += match[0].length
      return true
    }
    // 结束文字颜色
    if ((match = string.match(regexps.colorRestore)) &amp;&amp; this.colors.length > 1) {
      this.drawBuffer()
      this.colors.shift()
      this.index += match[0].length
      return true
    }
    // 使用字体
    if (match = string.match(regexps.font)) {
      const font = `${match[1]}${match[2] ? `, ${match[2]}` : ''}`
      this.drawBuffer()
      this.fonts.unshift(font)
      this.updateFont()
      this.index += match[0].length
      return true
    }
    // 结束字体
    if ((match = string.match(regexps.fontRestore)) &amp;&amp; this.fonts.length > 1) {
      this.drawBuffer()
      this.fonts.shift()
      this.updateFont()
      this.index += match[0].length
      return true
    }
    // 使用斜体样式
    if (match = string.match(regexps.italic)) {
      this.drawBuffer()
      this.styles.unshift('italic')
      this.updateFont()
      this.index += match[0].length
      return true
    }
    // 结束斜体样式
    if ((match = string.match(regexps.italicRestore)) &amp;&amp; this.styles.length > 1) {
      this.drawBuffer()
      this.styles.shift()
      this.updateFont()
      this.index += match[0].length
      return true
    }
    // 使用粗体字
    if (match = string.match(regexps.bold)) {
      this.drawBuffer()
      this.weights.unshift('bold')
      this.updateFont()
      this.index += match[0].length
      return true
    }
    // 结束粗体字
    if ((match = string.match(regexps.boldRestore)) &amp;&amp; this.weights.length > 1) {
      this.drawBuffer()
      this.weights.shift()
      this.updateFont()
      this.index += match[0].length
      return true
    }
    // 使用字体大小
    if (match = string.match(regexps.fontSize)) {
      const size = parseInt(match[1])
      this.drawBuffer()
      this.sizes.unshift(size)
      this.updateFont()
      this.index += match[0].length
      return true
    }
    // 结束字体大小
    if ((match = string.match(regexps.fontSizeRestore)) &amp;&amp; this.sizes.length > 1) {
      this.drawBuffer()
      this.sizes.shift()
      this.updateFont()
      this.index += match[0].length
      return true
    }
    // 设置文字位置
    if (match = string.match(regexps.textPosition)) {
      const axis = match[1].toLowerCase()
      const operation = match[2] || 'set'
      const value = parseInt(match[3])
      this.drawBuffer()
      const position = (
        operation === 'set' ? value
      : operation === 'add' ? this[axis] + value
      :                       null
      )
      this[axis] = Math.max(position, 0)
      this.index += match[0].length
      return true
    }
    // 使用阴影效果
    if (match = string.match(regexps.textShadow)) {
      const r = parseInt(match[3], 16)
      const g = parseInt(match[4], 16)
      const b = parseInt(match[5], 16)
      const a = parseInt(match[6] || 'ff', 16)
      const effect = {
        type: 'shadow',
        shadowOffsetX: parseInt(match[1]),
        shadowOffsetY: parseInt(match[2]),
        color: r + (g + (b + a * 256) * 256) * 256,
      }
      this.drawBuffer()
      this.effects.unshift(effect)
      this.index += match[0].length
      return true
    }
    // 结束阴影效果
    if ((match = string.match(regexps.textShadowRestore)) &amp;&amp; this.effects.length > 1 &amp;&amp; this.effects[0].type === 'shadow') {
      this.drawBuffer()
      this.effects.shift()
      this.index += match[0].length
      return true
    }
    // 使用描边效果
    if (match = string.match(regexps.textStroke)) {
      const r = parseInt(match[2], 16)
      const g = parseInt(match[3], 16)
      const b = parseInt(match[4], 16)
      const a = parseInt(match[5] || 'ff', 16)
      const effect = {
        type: 'stroke',
        strokeWidth: parseInt(match[1]),
        color: r + (g + (b + a * 256) * 256) * 256,
      }
      this.drawBuffer()
      this.effects.unshift(effect)
      this.index += match[0].length
      return true
    }
    // 结束描边效果
    if ((match = string.match(regexps.textStrokeRestore)) &amp;&amp; this.effects.length > 1 &amp;&amp; this.effects[0].type === 'stroke') {
      this.drawBuffer()
      this.effects.shift()
      this.index += match[0].length
      return true
    }
    // 使用轮廓效果
    if (match = string.match(regexps.textOutline)) {
      const r = parseInt(match[1], 16)
      const g = parseInt(match[2], 16)
      const b = parseInt(match[3], 16)
      const a = parseInt(match[4] || 'ff', 16)
      const effect = {
        type: 'outline',
        color: r + (g + (b + a * 256) * 256) * 256,
      }
      this.drawBuffer()
      this.effects.unshift(effect)
      this.index += match[0].length
      return true
    }
    // 结束轮廓效果
    if ((match = string.match(regexps.textOutlineRestore)) &amp;&amp; this.effects.length > 1 &amp;&amp; this.effects[0].type === 'outline') {
      this.drawBuffer()
      this.effects.shift()
      this.index += match[0].length
      return true
    }
    return false
  }

  // 静态属性
  static font = null
  static size = null
  static color = null
  static effect = null
  static wordWrap = ''
  static lineWidth = 0
  static charWidths = null
  static regexps = null
  static commands = null
  static commandCount = null
  static commandMaximum = null
  static drawingMethods = null
  static imported = []
  static importing = []

  // 标签正则表达式
  static regexps = {
    // 使用索引颜色: [1]:Index(0-15)
    colorIndex: /^&lt;color:(\d|1[0-5])>$/i,
    // 使用指定颜色: [1]:R(00-ff), [2]:G(00-ff), [3]:B(00-ff), [4]:A(00-ff)(可选)
    color: /^&lt;color:([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})?>$/i,
    // 结束文字颜色
    colorRestore: /^&lt;\/color>$/i,
    // 使用字体: [1]:字体族群
    font: /^&lt;font:([\S ]+)>$/i,
    // 结束字体
    fontRestore: /^&lt;\/font>$/i,
    // 使用斜体样式
    italic: /^&lt;italic>$/i,
    // 结束斜体样式
    italicRestore: /^&lt;\/italic>$/i,
    // 使用粗体字
    bold: /^&lt;bold>$/i,
    // 结束粗体字
    boldRestore: /^&lt;\/bold>$/i,
    // 使用字体大小: [1]:字体大小(10-400)
    fontSize: /^&lt;size:([1-9]\d|[1-3]\d\d|400)>$/i,
    // 结束字体大小
    fontSizeRestore: /^&lt;\/size>$/i,
    // 设置文字位置: [1]:坐标轴(x|y), [2]操作(add|undefined), [3]:数值(-1000-1000)
    textPosition: /^&lt;(x|y):(?:(add),)?(-?(?:\d|[1-9]\d|[1-9]\d\d|1000))>$/i,
    // 使用阴影效果: [1]:水平偏移(-9-9), [2]:垂直偏移(-9-9), [3]:R(00-ff), [4]:G(00-ff), [5]:B(00-ff), [6]:A(00-ff)(可选)
    textShadow: /^&lt;shadow:(0|-?[1-9]),(0|-?[1-9]),([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})?>$/i,
    // 结束阴影效果
    textShadowRestore: /^&lt;\/shadow>$/i,
    // 使用描边效果: [1]:描边宽度(1-20), [2]:R(00-ff), [3]:G(00-ff), [4]:B(00-ff), [5]:A(00-ff)(可选)
    textStroke: /^&lt;stroke:([1-9]|1\d|20),([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})?>$/i,
    // 结束描边效果
    textStrokeRestore: /^&lt;\/stroke>$/i,
    // 使用轮廓效果: [1]:R(00-ff), [2]:G(00-ff), [3]:B(00-ff), [4]:A(00-ff)(可选)
    textOutline: /^&lt;outline:([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})?>$/i,
    // 结束轮廓效果
    textOutlineRestore: /^&lt;\/outline>$/i,
  }

  /**
   * 初始化打印机相关数据
   * @returns {Promise}
   */
  static initialize() {
    // 设置字符宽度数组
    this.charWidths = new Float64Array(
      GL.arrays[1].uint32.buffer, 0,
      GL.arrays[1].uint32.length / 2,
    )

    // 创建打印机指令列表
    this.commandCount = 0
    this.commandMaximum = 100
    this.commands = new Array(this.commandMaximum)

    // 设置绘制方法映射表
    this.drawingMethods = {
      none: 'drawText',
      shadow: 'drawTextWithShadow',
      stroke: 'drawTextWithStroke',
      outline: 'drawTextWithOutline',
    }

    // 加载默认设置
    return this.loadDefault()
  }

  /**
   * 加载默认设置
   * @returns {Promise}
   */
  static loadDefault() {
    // 设置打印机默认上下文属性
    const text = Data.config.text
    this.font = text.fontFamily || 'sans-serif'
    this.size = 16
    this.color = Color.parseCSSColor('ffffffff')
    this.effect = {type: 'none'}
    this.wordWrap = text.wordWrap

    // 导入字体
    return this.importFonts(text.importedFonts)
  }

  /**
   * 导入字体
   * @param {string[]} imports 导入字体文件ID列表
   * @returns {Promise}
   */
  static importFonts(imports) {
    const imported = this.imported
    const importing = this.importing
    const regexp = /([^/]+)\.\S+\.\S+$/
    const promises = []
    for (const guid of imports) {
      const meta = Data.manifest.guidMap[guid]
      if (!meta) continue
      const path = meta.path
      const name = meta.name ?? path.match(regexp)?.[1]
      // 如果没有名字或已经加载，跳过
      if (!name || imported.includes(name)) {
        continue
      }
      imported.push(name)
      importing.push(name)
      promises.push(File.get({
        path: path,
        type: 'arraybuffer',
        sync: true,
      }).then(
        buffer => {
          new FontFace(name, buffer).load().then(
            font => {
              importing.remove(name)
              document.fonts.add(font)
            },
            error => {
              importing.remove(name)
            },
          )
        },
        error => {
          importing.remove(name)
        },
      ))
    }
    return Promise.all(promises)
  }

  /**
   * 解析文字效果
   * @param {Object} effect 文字效果数据对象
   * @returns {Object} 解析后的文字效果对象
   */
  static parseEffect(effect) {
    const copy = {...effect}
    if (copy.color !== undefined) {
      copy.color = Color.parseCSSColor(copy.color)
    }
    return copy
  }

  /**
   * 获取打印机指令
   * @returns {Object}
   */
  static fetchCommand() {
    const count = this.commandCount
    const command = this.commands[count]
    if (command !== undefined) {
      // 如果当前位置存在指令，返回
      this.commandCount++
      return command
    } else {
      // 创建新的打印机指令
      const command = {
        string: '',
        x: 0,
        y: 0,
        font: '',
        size: 0,
        color: 0,
        effect: null,
        horizontalWidth: 0,
        drawingMethod: '',
      }
      // 如果缓存指令数量未满，添加到指令池
      if (count &lt; this.commandMaximum) {
        this.commands[count] = command
        this.commandCount++
      }
      return command
    }
  }

  /** 重置打印机指令 */
  static resetCommands() {
    const commands = this.commands
    const count = this.commandCount
    for (let i = 0; i &lt; count; i++) {
      const command = commands[i]
      command.string = ''
    }
    this.commandCount = 0
  }

  /** 恢复打印机纹理 */
  static restoreTexture(base) {
    base.restoreNormalTexture()
    Promise.resolve().then(() => {
      const {content} = base.printer
      base.printer.reset()
      base.printer.draw(content)
    })
  }

  /**
   * 绘制文字
   * @param {CanvasRenderingContext2D} 2D上下文
   * @param {Object} command 打印机指令
   * @param {string} text 文本内容
   */
  static drawText(context, command, text) {
    const {font, size, color} = command
    const x = command.x
    const y = command.y + size * 0.85
    context.font = font
    context.fillStyle = color
    context.globalCompositeOperation = 'source-over'
    context.fillText(text, x, y)
  }

  /**
   * 绘制带阴影的文字
   * @param {CanvasRenderingContext2D} 2D上下文
   * @param {Object} command 打印机指令
   * @param {string} text 文本内容
   */
  static drawTextWithShadow(context, command, text) {
    const {font, size, color, effect} = command
    const x = command.x
    const y = command.y + size * 0.85
    context.font = font
    context.fillStyle = effect.color
    context.globalCompositeOperation = 'destination-over'
    context.fillText(text, x + effect.shadowOffsetX, y + effect.shadowOffsetY)
    context.fillStyle = color
    context.globalCompositeOperation = 'source-over'
    context.fillText(text, x, y)
  }

  /**
   * 绘制描边的文字
   * @param {CanvasRenderingContext2D} 2D上下文
   * @param {Object} command 打印机指令
   * @param {string} text 文本内容
   */
  static drawTextWithStroke(context, command, text) {
    const {font, size, color, effect} = command
    const x = command.x
    const y = command.y + size * 0.85
    context.font = font
    context.lineJoin = 'round'
    context.lineWidth = effect.strokeWidth
    context.strokeStyle = effect.color
    context.globalCompositeOperation = 'destination-over'
    context.strokeText(text, x, y)
    context.fillStyle = color
    context.globalCompositeOperation = 'source-over'
    context.fillText(text, x, y)
  }

  /**
   * 绘制带轮廓线的文字
   * @param {CanvasRenderingContext2D} 2D上下文
   * @param {Object} command 打印机指令
   * @param {string} text 文本内容
   */
  static drawTextWithOutline(context, command, text) {
    const {font, size, color, effect} = command
    const x = command.x
    const y = command.y + size * 0.85
    context.font = font
    context.fillStyle = effect.color
    context.fillText(text, x - 1, y)
    context.fillText(text, x + 1, y)
    context.fillText(text, x, y - 1)
    context.fillText(text, x, y + 1)
    context.fillStyle = color
    context.fillText(text, x, y)
  }
}</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Actor.html">Actor</a></li><li><a href="ActorCollider.html">ActorCollider</a></li><li><a href="ActorNavigator.html">ActorNavigator</a></li><li><a href="Animation.html">Animation</a></li><li><a href="AnimationController.html">AnimationController</a></li><li><a href="AudioPlayer.html">AudioPlayer</a></li><li><a href="AudioReverb.html">AudioReverb</a></li><li><a href="BatchRenderer.html">BatchRenderer</a></li><li><a href="CooldownItem.html">CooldownItem</a></li><li><a href="CooldownManager.html">CooldownManager</a></li><li><a href="DialogBoxElement.html">DialogBoxElement</a></li><li><a href="EasingMap.html">EasingMap</a></li><li><a href="Equipment.html">Equipment</a></li><li><a href="EquipmentManager.html">EquipmentManager</a></li><li><a href="EventHandler.html">EventHandler</a></li><li><a href="ImageElement.html">ImageElement</a></li><li><a href="ImageTexture.html">ImageTexture</a></li><li><a href="Inventory.html">Inventory</a></li><li><a href="Item.html">Item</a></li><li><a href="Matrix.html">Matrix</a></li><li><a href="MultipleAudioPlayer.html">MultipleAudioPlayer</a></li><li><a href="ParticleElement.html">ParticleElement</a></li><li><a href="ParticleEmitter.html">ParticleEmitter</a></li><li><a href="ParticleLayer.html">ParticleLayer</a></li><li><a href="Printer.html">Printer</a></li><li><a href="ProgressBarElement.html">ProgressBarElement</a></li><li><a href="SceneActorList.html">SceneActorList</a></li><li><a href="SceneAnimation.html">SceneAnimation</a></li><li><a href="SceneAnimationList.html">SceneAnimationList</a></li><li><a href="SceneContext.html">SceneContext</a></li><li><a href="SceneGridCellList.html">SceneGridCellList</a></li><li><a href="SceneLight.html">SceneLight</a></li><li><a href="SceneLightManager.html">SceneLightManager</a></li><li><a href="SceneObstacleArray.html">SceneObstacleArray</a></li><li><a href="SceneParallax.html">SceneParallax</a></li><li><a href="SceneParallaxManager.html">SceneParallaxManager</a></li><li><a href="SceneParticleEmitter.html">SceneParticleEmitter</a></li><li><a href="SceneParticleEmitterList.html">SceneParticleEmitterList</a></li><li><a href="SceneRegion.html">SceneRegion</a></li><li><a href="SceneRegionList.html">SceneRegionList</a></li><li><a href="SceneSpriteRenderer.html">SceneSpriteRenderer</a></li><li><a href="SceneTerrainArray.html">SceneTerrainArray</a></li><li><a href="SceneTilemap.html">SceneTilemap</a></li><li><a href="SceneTriggerList.html">SceneTriggerList</a></li><li><a href="Script.html">Script</a></li><li><a href="Shortcut.html">Shortcut</a></li><li><a href="Skill.html">Skill</a></li><li><a href="SkillCooldownList.html">SkillCooldownList</a></li><li><a href="SkillManager.html">SkillManager</a></li><li><a href="State.html">State</a></li><li><a href="StateCountdownList.html">StateCountdownList</a></li><li><a href="StateManager.html">StateManager</a></li><li><a href="TargetManager.html">TargetManager</a></li><li><a href="TextBoxElement.html">TextBoxElement</a></li><li><a href="TextElement.html">TextElement</a></li><li><a href="Texture.html">Texture</a></li><li><a href="TextureManager.html">TextureManager</a></li><li><a href="Timer.html">Timer</a></li><li><a href="Trigger.html">Trigger</a></li><li><a href="UIElement.html">UIElement</a></li><li><a href="VideoElement.html">VideoElement</a></li><li><a href="WindowElement.html">WindowElement</a></li></ul><h3>Global</h3><ul><li><a href="global.html#GL">GL</a></li><li><a href="global.html#_createElement">_createElement</a></li><li><a href="global.html#_updateBubbleState">_updateBubbleState</a></li><li><a href="global.html#activate">activate</a></li><li><a href="global.html#add">add</a></li><li><a href="global.html#addMember">addMember</a></li><li><a href="global.html#addPointerEventRoot">addPointerEventRoot</a></li><li><a href="global.html#append">append</a></li><li><a href="global.html#autorun">autorun</a></li><li><a href="global.html#bind">bind</a></li><li><a href="global.html#buildPath">buildPath</a></li><li><a href="global.html#calculateCoords">calculateCoords</a></li><li><a href="global.html#calculateSceneCoords">calculateSceneCoords</a></li><li><a href="global.html#call">call</a></li><li><a href="global.html#callAutorunEvents">callAutorunEvents</a></li><li><a href="global.html#callSpecialEvent">callSpecialEvent</a></li><li><a href="global.html#changeRelation">changeRelation</a></li><li><a href="global.html#checkIfRemovedHover">checkIfRemovedHover</a></li><li><a href="global.html#clearGlobalActors">clearGlobalActors</a></li><li><a href="global.html#compileEvents">compileEvents</a></li><li><a href="global.html#continue">continue</a></li><li><a href="global.html#convertToScreenCoords">convertToScreenCoords</a></li><li><a href="global.html#create">create</a></li><li><a href="global.html#createAutotileMap">createAutotileMap</a></li><li><a href="global.html#createEasingMap">createEasingMap</a></li><li><a href="global.html#createElement">createElement</a></li><li><a href="global.html#createFollower">createFollower</a></li><li><a href="global.html#createMembers">createMembers</a></li><li><a href="global.html#createPath">createPath</a></li><li><a href="global.html#createPlayer">createPlayer</a></li><li><a href="global.html#createUnitPath">createUnitPath</a></li><li><a href="global.html#decodeClone">decodeClone</a></li><li><a href="global.html#decodeTeamData">decodeTeamData</a></li><li><a href="global.html#decodeTerrains">decodeTerrains</a></li><li><a href="global.html#decodeTiles">decodeTiles</a></li><li><a href="global.html#delete">delete</a></li><li><a href="global.html#deleteGameData">deleteGameData</a></li><li><a href="global.html#disable">disable</a></li><li><a href="global.html#displayErrorMessage">displayErrorMessage</a></li><li><a href="global.html#doubleclick">doubleclick</a></li><li><a href="global.html#emit">emit</a></li><li><a href="global.html#emitInputEvent">emitInputEvent</a></li><li><a href="global.html#enable">enable</a></li><li><a href="global.html#encodeTeamData">encodeTeamData</a></li><li><a href="global.html#encodeTerrains">encodeTerrains</a></li><li><a href="global.html#executeCallbacks">executeCallbacks</a></li><li><a href="global.html#find">find</a></li><li><a href="global.html#follow">follow</a></li><li><a href="global.html#gamepadbuttonpress">gamepadbuttonpress</a></li><li><a href="global.html#gamepadbuttonrelease">gamepadbuttonrelease</a></li><li><a href="global.html#gamepadleftstickchange">gamepadleftstickchange</a></li><li><a href="global.html#gamepadrightstickchange">gamepadrightstickchange</a></li><li><a href="global.html#generate32bit">generate32bit</a></li><li><a href="global.html#generate64bit">generate64bit</a></li><li><a href="global.html#get">get</a></li><li><a href="global.html#getElementAtMouse">getElementAtMouse</a></li><li><a href="global.html#getGroup">getGroup</a></li><li><a href="global.html#getItem">getItem</a></li><li><a href="global.html#getKey">getKey</a></li><li><a href="global.html#getKeys">getKeys</a></li><li><a href="global.html#getName">getName</a></li><li><a href="global.html#getParallaxAnchor">getParallaxAnchor</a></li><li><a href="global.html#getPathByGUID">getPathByGUID</a></li><li><a href="global.html#getPointerEventRoot">getPointerEventRoot</a></li><li><a href="global.html#getRelationByIndexes">getRelationByIndexes</a></li><li><a href="global.html#getValue">getValue</a></li><li><a href="global.html#initialize">initialize</a></li><li><a href="global.html#isEnemy">isEnemy</a></li><li><a href="global.html#isFriendly">isFriendly</a></li><li><a href="global.html#isMacOS">isMacOS</a></li><li><a href="global.html#keydown">keydown</a></li><li><a href="global.html#keydownFilter">keydownFilter</a></li><li><a href="global.html#keyup">keyup</a></li><li><a href="global.html#load">load</a></li><li><a href="global.html#loadData">loadData</a></li><li><a href="global.html#loadFile">loadFile</a></li><li><a href="global.html#loadGameData">loadGameData</a></li><li><a href="global.html#loadGlobalData">loadGlobalData</a></li><li><a href="global.html#loadMeta">loadMeta</a></li><li><a href="global.html#loadObjects">loadObjects</a></li><li><a href="global.html#loadPresets">loadPresets</a></li><li><a href="global.html#loadSaveMeta">loadSaveMeta</a></li><li><a href="global.html#loadScene">loadScene</a></li><li><a href="global.html#loadScripts">loadScripts</a></li><li><a href="global.html#loadUI">loadUI</a></li><li><a href="global.html#mousedown">mousedown</a></li><li><a href="global.html#mousedownLB">mousedownLB</a></li><li><a href="global.html#mousedownRB">mousedownRB</a></li><li><a href="global.html#mouseleave">mouseleave</a></li><li><a href="global.html#mousemove">mousemove</a></li><li><a href="global.html#mouseup">mouseup</a></li><li><a href="global.html#mouseupLB">mouseupLB</a></li><li><a href="global.html#mouseupRB">mouseupRB</a></li><li><a href="global.html#moveTo">moveTo</a></li><li><a href="global.html#off">off</a></li><li><a href="global.html#on">on</a></li><li><a href="global.html#onTransitionEnd">onTransitionEnd</a></li><li><a href="global.html#open">open</a></li><li><a href="global.html#parseCSSColor">parseCSSColor</a></li><li><a href="global.html#parseDateTimestamp">parseDateTimestamp</a></li><li><a href="global.html#parseFloatArray">parseFloatArray</a></li><li><a href="global.html#parseFloatArrayTag">parseFloatArrayTag</a></li><li><a href="global.html#parseGUID">parseGUID</a></li><li><a href="global.html#parseInt">parseInt</a></li><li><a href="global.html#parseIntArray">parseIntArray</a></li><li><a href="global.html#pause">pause</a></li><li><a href="global.html#pointerdown">pointerdown</a></li><li><a href="global.html#pointerenter">pointerenter</a></li><li><a href="global.html#pointerleave">pointerleave</a></li><li><a href="global.html#pointermove">pointermove</a></li><li><a href="global.html#pointerup">pointerup</a></li><li><a href="global.html#pop">pop</a></li><li><a href="global.html#precompile">precompile</a></li><li><a href="global.html#precompileActors">precompileActors</a></li><li><a href="global.html#precompileAnimations">precompileAnimations</a></li><li><a href="global.html#precompileEquipments">precompileEquipments</a></li><li><a href="global.html#precompileItems">precompileItems</a></li><li><a href="global.html#precompileSkills">precompileSkills</a></li><li><a href="global.html#precompileStates">precompileStates</a></li><li><a href="global.html#precompileTriggers">precompileTriggers</a></li><li><a href="global.html#preventInput">preventInput</a></li><li><a href="global.html#push">push</a></li><li><a href="global.html#remapScripts">remapScripts</a></li><li><a href="global.html#remove">remove</a></li><li><a href="global.html#removeItem">removeItem</a></li><li><a href="global.html#removeLatestPointerEventRoot">removeLatestPointerEventRoot</a></li><li><a href="global.html#removeMember">removeMember</a></li><li><a href="global.html#removePointerEventRoot">removePointerEventRoot</a></li><li><a href="global.html#render">render</a></li><li><a href="global.html#renderLoadingProgress">renderLoadingProgress</a></li><li><a href="global.html#reset">reset</a></li><li><a href="global.html#resetPointerEventRoots">resetPointerEventRoots</a></li><li><a href="global.html#resize">resize</a></li><li><a href="global.html#restoreInput">restoreInput</a></li><li><a href="global.html#rotateAndScaleCanvas">rotateAndScaleCanvas</a></li><li><a href="global.html#route">route</a></li><li><a href="global.html#saveData">saveData</a></li><li><a href="global.html#saveGameData">saveGameData</a></li><li><a href="global.html#saveGlobalData">saveGlobalData</a></li><li><a href="global.html#scaleCanvas">scaleCanvas</a></li><li><a href="global.html#set">set</a></li><li><a href="global.html#setBypass">setBypass</a></li><li><a href="global.html#setItem">setItem</a></li><li><a href="global.html#setPlayer">setPlayer</a></li><li><a href="global.html#setTimeScale">setTimeScale</a></li><li><a href="global.html#setToHighestPriority">setToHighestPriority</a></li><li><a href="global.html#setZoomFactor">setZoomFactor</a></li><li><a href="global.html#shake">shake</a></li><li><a href="global.html#shareInventory">shareInventory</a></li><li><a href="global.html#simulateKey">simulateKey</a></li><li><a href="global.html#start">start</a></li><li><a href="global.html#stop">stop</a></li><li><a href="global.html#switchGameInfoDisplay">switchGameInfoDisplay</a></li><li><a href="global.html#testConditions">testConditions</a></li><li><a href="global.html#unfollow">unfollow</a></li><li><a href="global.html#unpack">unpack</a></li><li><a href="global.html#unpackTeamData">unpackTeamData</a></li><li><a href="global.html#update">update</a></li><li><a href="global.html#updateLoadingProgress">updateLoadingProgress</a></li><li><a href="global.html#wheel">wheel</a></li><li><a href="global.html#xhr">xhr</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.2</a> on Mon Aug 21 2023 21:54:29 GMT+0800 (中国标准时间)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
